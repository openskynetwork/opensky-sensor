[Watchdog]
; Enable the watchdog (set to true unless in network mode)
Enabled = true



[FPGA]
; Configure the FPGA (will reset the ADSB receiver; overridden in network mode)
Configure = true

; FPGA Configuration file to read from
File = openskyd.rbf

; Retry limit
Retries = 2

; Timeout to wait for the FPGA in units of 50us
Timeout = 10



[ADSB]
; Uart to be used, don't change unless you know what you're doing
uart = /dev/ttyO5

; Host to connect to in network mode
host = localhost

; Port to connect to in network mode
port = 10003

; Sleeping duration to be when trying to reestablish a broken connection in s
ReconnectInterval = 10

; Configure the ADSB receiver with the values below; overridden in network mode
Configure = true

; Enable Checksum: if a received frame fails the test, it's discarded
CRC = true

; Enable Error Correction
FEC = true

; Enable Frame filtering: if enabled, only DF-11/17/18 messages are received
FrameFilter = true

; Enable Mode-A/C reception
ModeAC = false

; Enable RTS/CTS Flow Control on UART
RTS = true

; Use GPS timestamps for the MLAT; else the legacy 12MHz clock is used
GPS = true

; Enable reception of Mode-S Short frames (software filter)
ModeS_Short = false

; Enable reception of Mode-S Long frames (software filter)
ModeS_Long = true

; Enable reception of Mode-S Long (Extended Squitter) only (software filter)   
ModeS_Long_ExtSquitterOnly = true



[Network]
; Host to connect to
Host = collector.opensky-network.org

; Port to connect to
Port = 10004

; Timeout (for frame reception) to be used before sending an alive message in ms
Timeout = 1500

; Sleeping duration to be when trying to reestablish a broken connection in s
ReconnectInterval = 10



[Buffer]
; Record history when the connection is broken (if not, all frames are discarded
;  while there is no connection)
History = false

; Minimum Pool size (this is used for very small glitches of the network)
;  must be more than 2, should be about 5-10
StaticBacklog = 10

; Number of frames to be added to the pool if its full. Shouldn't be too high
;  (i.e. up to 1000), since those frames are allocated in one bin allocation
DynamicBacklog = 1000

; Number of times to increment the pool
DynamicIncrement = 1080

; Enable Garbage collection of dynamically allocated frames (should be true if
;  "History" is enabled)
GCEnabled = false

; Interval to be used for garbage collection in s. Should be above 2 Minutes
GCInterval = 120

; Threshold to actually run garbage collection: it's run only, if the size of
;  the current output queue is less than 1/GCLevel of the number of dynamically
;  allocated frames. Should be about 2-4.
GCLevel = 2



[Statistics]
; Enable periodic output of some statistics
Enabled = true

; Interval between two reports
Interval = 600



[Device]
; Serial number of the device (as seen on the bottom of the device 
;  without the '-'). Default will be calculated from the MAC Address of eth0
;Serial = 
